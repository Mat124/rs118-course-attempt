<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Calloop, a Callback-based Event Loop"><meta name="keywords" content="rust, rustlang, rust-lang, calloop"><title>calloop - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../calloop/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../calloop/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate calloop</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.9.3</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div></section><div id="sidebar-vars" data-name="calloop" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../calloop/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">calloop</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/calloop/lib.rs.html#1-151">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Calloop, a Callback-based Event Loop</p>
<p>This crate provides an <a href="struct.EventLoop.html" title="EventLoop"><code>EventLoop</code></a> type, which is a small abstraction
over a polling system. The main difference between this crate
and other traditional rust event loops is that it is based on callbacks:
you can register several event sources, each being associated with a callback
closure that will be invoked whenever the associated event source generates
events.</p>
<p>The main target use of this event loop is thus for apps that expect to spend
most of their time waiting for events and wishes to do so in a cheap and convenient
way. It is not meant for large scale high performance IO.</p>
<h3 id="how-to-use-it"><a href="#how-to-use-it">How to use it</a></h3>
<p>For simple uses, you can just add event sources with callbacks to the event
loop. For example, here’s a runnable program that exits after five seconds:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">calloop</span>::{<span class="ident">timer::Timer</span>, <span class="ident">EventLoop</span>, <span class="ident">LoopSignal</span>};

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create the event loop. The loop is parameterised by the kind of shared</span>
    <span class="comment">// data you want the callbacks to use. In this case, we want to be able to</span>
    <span class="comment">// stop the loop when the timer fires, so we provide the loop with a</span>
    <span class="comment">// LoopSignal, which has the ability to stop the loop from within events. We</span>
    <span class="comment">// just annotate the type here; the actual data is provided later in the</span>
    <span class="comment">// run() call.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">event_loop</span>: <span class="ident">EventLoop</span><span class="op">&lt;</span><span class="ident">LoopSignal</span><span class="op">&gt;</span> <span class="op">=</span>
        <span class="ident">EventLoop::try_new</span>().<span class="ident">expect</span>(<span class="string">&quot;Failed to initialize the event loop!&quot;</span>);

    <span class="comment">// Retrieve a handle. It is used to insert new sources into the event loop</span>
    <span class="comment">// It can be cloned, allowing you to insert sources from within source</span>
    <span class="comment">// callbacks.</span>
    <span class="kw">let</span> <span class="ident">handle</span> <span class="op">=</span> <span class="ident">event_loop</span>.<span class="ident">handle</span>();

    <span class="comment">// Create our event source, a timer. Note that this is also parameterised by</span>
    <span class="comment">// the data for the events it generates. We&#39;ve let Rust infer that here.</span>
    <span class="kw">let</span> <span class="ident">source</span> <span class="op">=</span> <span class="ident">Timer::new</span>().<span class="ident">expect</span>(<span class="string">&quot;Failed to create timer event source!&quot;</span>);

    <span class="comment">// Most event source APIs provide two things: an event source to go into the</span>
    <span class="comment">// event loop, and some way of triggering that source from elsewhere. In</span>
    <span class="comment">// this case, we use a handle to the timer to set timeouts.</span>
    <span class="comment">//</span>
    <span class="comment">// Note that this can go before or after the call to insert_source(), and</span>
    <span class="comment">// even inside another event callback.</span>
    <span class="kw">let</span> <span class="ident">timer_handle</span> <span class="op">=</span> <span class="ident">source</span>.<span class="ident">handle</span>();
    <span class="ident">timer_handle</span>.<span class="ident">add_timeout</span>(<span class="ident">std::time::Duration::from_secs</span>(<span class="number">5</span>), <span class="string">&quot;Timeout reached!&quot;</span>);

    <span class="comment">// Inserting an event source takes this general form. It can also be done</span>
    <span class="comment">// from within the callback of another event source.</span>
    <span class="ident">handle</span>
        .<span class="ident">insert_source</span>(
            <span class="comment">// a type which implements the EventSource trait</span>
            <span class="ident">source</span>,
            <span class="comment">// a callback that is invoked whenever this source generates an event</span>
            <span class="op">|</span><span class="ident">event</span>, <span class="ident">_metadata</span>, <span class="ident">shared_data</span><span class="op">|</span> {
                <span class="comment">// This callback is given 3 values:</span>
                <span class="comment">// - the event generated by the source (in our case, a string slice)</span>
                <span class="comment">// - &amp;mut access to some metadata, specific to the event source (in our case, a</span>
                <span class="comment">//   timer handle)</span>
                <span class="comment">// - &amp;mut access to the global shared data that was passed to EventLoop::run or</span>
                <span class="comment">//   EventLoop::dispatch (in our case, a LoopSignal object to stop the loop)</span>
                <span class="comment">//</span>
                <span class="comment">// The return type is just () because nothing uses it. Some</span>
                <span class="comment">// sources will expect a Result of some kind instead.</span>
                <span class="macro">println!</span>(<span class="string">&quot;Event fired: {}&quot;</span>, <span class="ident">event</span>);
                <span class="ident">shared_data</span>.<span class="ident">stop</span>();
            },
        )
        .<span class="ident">expect</span>(<span class="string">&quot;Failed to insert event source!&quot;</span>);

    <span class="comment">// Create the shared data for our loop.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">shared_data</span> <span class="op">=</span> <span class="ident">event_loop</span>.<span class="ident">get_signal</span>();

    <span class="comment">// Actually run the event loop. This will dispatch received events to their</span>
    <span class="comment">// callbacks, waiting at most 20ms for new events between each invocation of</span>
    <span class="comment">// the provided callback (pass None for the timeout argument if you want to</span>
    <span class="comment">// wait indefinitely between events).</span>
    <span class="comment">//</span>
    <span class="comment">// This is where we pass the *value* of the shared data, as a mutable</span>
    <span class="comment">// reference that will be forwarded to all your callbacks, allowing them to</span>
    <span class="comment">// share some state</span>
    <span class="ident">event_loop</span>
        .<span class="ident">run</span>(
            <span class="ident">std::time::Duration::from_millis</span>(<span class="number">20</span>),
            <span class="kw-2">&amp;mut</span> <span class="ident">shared_data</span>,
            <span class="op">|</span><span class="ident">_shared_data</span><span class="op">|</span> {
                <span class="comment">// Finally, this is where you can insert the processing you need</span>
                <span class="comment">// to do do between each waiting event eg. drawing logic if</span>
                <span class="comment">// you&#39;re doing a GUI app.</span>
            },
        )
        .<span class="ident">expect</span>(<span class="string">&quot;Error during event loop!&quot;</span>);
}</code></pre></div>
<h3 id="event-source-types"><a href="#event-source-types">Event source types</a></h3>
<p>The event loop is backed by an OS provided polling selector (epoll on Linux).</p>
<p>This crate also provide some adapters for common event sources such as:</p>
<ul>
<li><a href="channel/index.html">MPSC channels</a></li>
<li><a href="timer/index.html">Timers</a></li>
<li><a href="signals/index.html">unix signals</a> on Linux</li>
</ul>
<p>As well as generic objects backed by file descriptors.</p>
<p>It is also possible to insert “idle” callbacks. These callbacks represent computations that
need to be done at some point, but are not as urgent as processing the events. These callbacks
are stored and then executed during <a href="struct.EventLoop.html#method.dispatch"><code>EventLoop::dispatch</code></a>, once all
events from the sources have been processed.</p>
<h3 id="asyncawait-compatibility"><a href="#asyncawait-compatibility">Async/Await compatibility</a></h3>
<p><code>calloop</code> can be used with futures, both as an executor and for monitoring Async IO.</p>
<p>Activating the <code>executor</code> cargo feature will add the [<code>futures</code>] module, which provides
a future executor that can be inserted into an <a href="struct.EventLoop.html" title="EventLoop"><code>EventLoop</code></a> as yet another <a href="trait.EventSource.html" title="EventSource"><code>EventSource</code></a>.</p>
<p>IO objects can be made Async-aware via the <a href="struct.LoopHandle.html#method.adapt_io"><code>LoopHandle::adapt_io</code></a>
method. Waking up the futures using these objects is handled by the associated <a href="struct.EventLoop.html" title="EventLoop"><code>EventLoop</code></a>
directly.</p>
<h3 id="custom-event-sources"><a href="#custom-event-sources">Custom event sources</a></h3>
<p>You can create custom event sources can will be inserted in the event loop by
implementing the <a href="trait.EventSource.html" title="EventSource"><code>EventSource</code></a> trait. This can be done either directly from the file
descriptors of your source of interest, or by wrapping an other event source and further
processing its events. An <a href="trait.EventSource.html" title="EventSource"><code>EventSource</code></a> can register more than one file descriptor and
aggregate them.</p>
<h3 id="platforms-support"><a href="#platforms-support">Platforms support</a></h3>
<p>Currently, only Linux and the *BSD are supported.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="channel/index.html" title="calloop::channel mod">channel</a></div><div class="item-right docblock-short"><p>An MPSC channel whose receiving end is an event source</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="generic/index.html" title="calloop::generic mod">generic</a></div><div class="item-right docblock-short"><p>A generic event source wrapping an IO objects or file descriptor</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="io/index.html" title="calloop::io mod">io</a></div><div class="item-right docblock-short"><p>Adapters for async IO objects</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="ping/index.html" title="calloop::ping mod">ping</a></div><div class="item-right docblock-short"><p>Ping to the event loop</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="signals/index.html" title="calloop::signals mod">signals</a></div><div class="item-right docblock-short"><p>Event source for tracking Unix signals</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="timer/index.html" title="calloop::timer mod">timer</a></div><div class="item-right docblock-short"><p>Timer-based event sources</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Dispatcher.html" title="calloop::Dispatcher struct">Dispatcher</a></div><div class="item-right docblock-short"><p>An event source with its callback.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EventLoop.html" title="calloop::EventLoop struct">EventLoop</a></div><div class="item-right docblock-short"><p>An event loop</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Idle.html" title="calloop::Idle struct">Idle</a></div><div class="item-right docblock-short"><p>An idle callback that was inserted in this loop</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InsertError.html" title="calloop::InsertError struct">InsertError</a></div><div class="item-right docblock-short"><p>An error generated when trying to insert an event source</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Interest.html" title="calloop::Interest struct">Interest</a></div><div class="item-right docblock-short"><p>Interest to register regarding the file descriptor</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LoopHandle.html" title="calloop::LoopHandle struct">LoopHandle</a></div><div class="item-right docblock-short"><p>An handle to an event loop</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LoopSignal.html" title="calloop::LoopSignal struct">LoopSignal</a></div><div class="item-right docblock-short"><p>A signal that can be shared between thread to stop or wakeup a running
event loop</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Poll.html" title="calloop::Poll struct">Poll</a></div><div class="item-right docblock-short"><p>The polling system</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Readiness.html" title="calloop::Readiness struct">Readiness</a></div><div class="item-right docblock-short"><p>Readiness for a file descriptor notification</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RegistrationToken.html" title="calloop::RegistrationToken struct">RegistrationToken</a></div><div class="item-right docblock-short"><p>A token representing a registration in the <a href="struct.EventLoop.html" title="EventLoop"><code>EventLoop</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Token.html" title="calloop::Token struct">Token</a></div><div class="item-right docblock-short"><p>A token (for implementation of the <a href="trait.EventSource.html"><code>EventSource</code></a> trait)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TokenFactory.html" title="calloop::TokenFactory struct">TokenFactory</a></div><div class="item-right docblock-short"><p>Factory for creating tokens in your registrations</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Mode.html" title="calloop::Mode enum">Mode</a></div><div class="item-right docblock-short"><p>Possible modes for registering a file descriptor</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.PostAction.html" title="calloop::PostAction enum">PostAction</a></div><div class="item-right docblock-short"><p>Possible actions that can be requested to the event loop by an
event source once its events have been processed</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.EventSource.html" title="calloop::EventSource trait">EventSource</a></div><div class="item-right docblock-short"><p>Trait representing an event source</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="calloop" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>